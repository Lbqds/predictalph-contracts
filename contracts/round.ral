Contract Round(
    prediction: Predictalph,
    epoch: U256,
    priceStart: U256,
    feesBasisPts: U256,
    bidEndTimestamp: U256,
    operator: Address,
    mut priceEnd: U256,
    mut totalAmount: U256,
    mut amountUp: U256,
    mut amountDown: U256,
    mut treasuryAmount: U256,
    mut rewardAmount: U256,
    mut rewardBaseCalAmount: U256
){


    enum ErrorCodes {
        InvalidCaller = 100
        NotAllPlayerClaimed = 101
        HouseWon = 102
        RewardsAlreadyComputed = 103
        BidTimestampNotReached = 104
    }


    pub fn getEndRoundTime() -> (U256) {
        return bidEndTimestamp
    }

    pub fn getRewardAmount() -> (U256) {
        return treasuryAmount
    }

    pub fn getRewardBaseCalAmount() -> (U256){
        return rewardBaseCalAmount
    }


    pub fn getRoundEpoch() -> (U256){
        return epoch
    }


    @using(updateFields = true, assetsInContract = true, preapprovedAssets = true)
    pub fn updateAmount(from: Address, amount: U256, up: Bool) -> () {
        checkCaller!(callerContractId!() == contractId!(prediction), ErrorCodes.InvalidCaller)

        totalAmount = totalAmount + amount
        
        if (up) {
            amountUp = amountUp + amount
        } else {
            amountDown = amountDown + amount
        }

        transferTokenToSelf!(from, ALPH, amount)
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn calculateRewards(price: U256) -> (){
        assert!(bidEndTimestamp > blockTimeStamp!(), ErrorCodes.BidTimestampNotReached)
        assert!(treasuryAmount <= 0, ErrorCodes.RewardsAlreadyComputed)


        priceEnd = price
        if (priceStart > priceEnd) {
            rewardBaseCalAmount = amountUp
            treasuryAmount = (totalAmount * feesBasisPts)/10000
            rewardAmount = totalAmount - treasuryAmount
        } else if (priceStart < priceEnd){
            rewardBaseCalAmount = amountDown
            treasuryAmount = (totalAmount * feesBasisPts)/10000
            rewardAmount = totalAmount - treasuryAmount
        } else {
            // all in fees pool
            rewardBaseCalAmount = 0
            rewardAmount = 0
            treasuryAmount = totalAmount
        }
    }

    @using(assetsInContract = true)
    pub fn claimContract() -> (){
        checkCaller!(callerAddress!() == operator, ErrorCodes.InvalidCaller)

        let tokenRemaining = tokenRemaining!(selfAddress!(), ALPH)
        assert!(tokenRemaining <= treasuryAmount, ErrorCodes.NotAllPlayerClaimed)
        destroySelf!(operator)
    }

    @using(updateFields = true, assetsInContract = true)
    pub fn userClaimRewards(addressPunter: Address, amountBid: U256, upBid: Bool) -> (){
        checkCaller!(callerContractId!() == contractId!(prediction), ErrorCodes.InvalidCaller)
        assert!(rewardAmount > 0, ErrorCodes.HouseWon)

        let mut userReward = 0
        if(priceStart > priceEnd && upBid || priceStart < priceEnd && !upBid ) {
            userReward = (amountBid * rewardAmount) / rewardBaseCalAmount
        }


        if(userReward > 0){
            transferTokenFromSelf!(addressPunter, ALPH, userReward)
            totalAmount = totalAmount - userReward
        }
    }

}